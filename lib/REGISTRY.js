// Generated by CoffeeScript 1.7.1
(function() {
  var $, ASYNC, KEY, P, TRM, TYPES, alert, badge, debug, echo, help, indexes, info, log, new_db, njs_fs, options, rainbow, rpr, test_folder_exists, urge, warn, whisper;

  njs_fs = require('fs');

  TYPES = require('coffeenode-types');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'TIMETABLE/REGISTRY';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);

  options = require('../options');

  indexes = options['data']['indexes'];

  new_db = require('level');

  ASYNC = require('async');

  P = require('pipedreams');

  $ = P.$.bind(P);

  KEY = require('./KEY');

  test_folder_exists = function(route) {
    var is_folder;
    if (!njs_fs.existsSync(route)) {
      return false;
    }
    is_folder = (njs_fs.statSync(route)).isDirectory();
    if (!is_folder) {
      throw new Error("route exists but is not a folder: " + route);
    }
    return true;
  };

  this.new_registry = function(route) {
    if (route == null) {
      route = options['levelup']['route'];
    }
    return new_db(route, options['levelup']['new']);
  };

  this._new_registry = function(route) {
    var folder_exists, registry;
    if (route == null) {
      route = options['levelup']['route'];
    }
    folder_exists = test_folder_exists(route);
    registry = this.new_registry(route);
    return [folder_exists, registry];
  };

  this.close = function(registry, handler) {
    return registry.close((function(_this) {
      return function(error) {
        help('registry closed');
        return handler(error);
      };
    })(this));
  };

  this.flush = function(registry, handler) {
    return registry.close((function(_this) {
      return function(error) {
        if (error != null) {
          return handler(error);
        }
        return registry.open(function(error) {
          help('registry flushed');
          return handler(error, registry);
        });
      };
    })(this));
  };

  this.register = function(registry, record, handler) {
    var id, value;
    id = record['id'];
    if (id == null) {
      throw new Error("unable to register record without ID:\n" + (rpr(record)));
    }

    /* Records whose only attribute is the ID field are replaced by `1`: */
    value = (Object.keys(record)).length === 1 ? 1 : record;
    return registry.put(id, value, (function(_this) {
      return function(error) {
        if (error != null) {
          return handler(error);
        }
        return handler(null, record);
      };
    })(this));
  };

  this.$register = function(registry) {
    return $((function(_this) {
      return function(record, handler) {
        return _this.register(registry, record, function(error) {
          if (error != null) {
            return handler(error);
          }
          return handler(null, record);
        });
      };
    })(this));
  };

  this.register_2 = function(registry, record, handler) {

    /* TAINT kludge, change to using strings as records */
    var id, idn, idn_1, key, keys, meta_value, name, realm, realm_1, route, tasks, type, type_1, value, _, _fn, _i, _len, _ref, _ref1;
    id = record['id'];
    if (id == null) {
      throw new Error("unable to register record without ID:\n" + (rpr(record)));
    }

    /* TAINT kludge, must be changed in GTFS reader */
    _ref = id.split('/'), realm = _ref[0], type = _ref[1], idn = _ref[2];
    route = KEY.new_route(realm, type);
    meta_value = '1';
    tasks = [];
    for (name in record) {
      value = record[name];
      if (name === 'id') {
        continue;
      }
      if (name === 'gtfs-id') {
        continue;
      }
      if (name === 'gtfs-type') {
        continue;
      }
      if (!TYPES.isa_text(value)) {
        value = rpr(value);
      }
      keys = [];

      /* TAINT must apply escaping or use KEY method */
      route = [realm, type, name].join(options['keys']['slash']);
      if (/-id$/.test(name)) {
        idn_1 = value;
        _ref1 = name.split('-'), realm_1 = _ref1[0], type_1 = _ref1[1], _ = _ref1[2];
        keys.push(KEY.new_link(realm, type, idn, realm_1, type_1, idn_1, 0));
        if (indexes[route]) {
          keys.push(KEY.new_secondary_link(realm, type, idn, realm_1, type_1, idn_1, 0));
        }
      } else {
        keys.push(KEY.new_facet(realm, type, idn, name, value));
        if (indexes[route]) {
          keys.push(KEY.new_secondary_facet(realm, type, idn, name, value));
        }
      }
      _fn = function(key) {
        return tasks.push((function(_this) {
          return function(handler) {
            return registry.put(key, meta_value, function(error) {
              return handler(error != null ? error : null);
            });
          };
        })(this));
      };
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        key = keys[_i];
        _fn(key);
      }
    }
    return ASYNC.parallel(tasks, (function(_this) {
      return function(error) {
        return handler(error != null ? error : null);
      };
    })(this));
  };

  this.$register_2 = function(registry) {
    return $((function(_this) {
      return function(record, handler) {
        return _this.register_2(registry, record, function(error) {
          if (error != null) {
            return handler(error);
          }
          return handler(null, record);
        });
      };
    })(this));
  };

}).call(this);
