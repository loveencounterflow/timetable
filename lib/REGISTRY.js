// Generated by CoffeeScript 1.7.1
(function() {
  var $, ASYNC, KEY, P, TRM, TYPES, alert, badge, debug, echo, help, indexes, info, log, new_db, njs_fs, options, rainbow, registry, rpr, test_folder_exists, urge, warn, whisper;

  njs_fs = require('fs');

  TYPES = require('coffeenode-types');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'TIMETABLE/REGISTRY';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);

  options = require('../options');

  indexes = options['data']['indexes'];

  new_db = require('level');

  ASYNC = require('async');

  P = require('pipedreams');

  $ = P.$.bind(P);

  KEY = require('./KEY');

  test_folder_exists = function(route) {
    var is_folder;
    if (!njs_fs.existsSync(route)) {
      return false;
    }
    is_folder = (njs_fs.statSync(route)).isDirectory();
    if (!is_folder) {
      throw new Error("route exists but is not a folder: " + route);
    }
    return true;
  };

  this.new_registry = function(route) {
    if (route == null) {
      route = options['levelup']['route'];
    }
    return new_db(route, options['levelup']['new']);
  };

  this._new_registry = function(route) {
    var folder_exists, registry;
    if (route == null) {
      route = options['levelup']['route'];
    }
    folder_exists = test_folder_exists(route);
    registry = this.new_registry(route);
    return [folder_exists, registry];
  };

  this.close = function(registry, handler) {
    return registry.close((function(_this) {
      return function(error) {
        help('registry closed');
        return handler(error);
      };
    })(this));
  };

  this.flush = function(registry, handler) {
    return registry.close((function(_this) {
      return function(error) {
        if (error != null) {
          return handler(error);
        }
        return registry.open(function(error) {
          help('registry flushed');
          return handler(error, registry);
        });
      };
    })(this));
  };

  this.register = function(registry, record, handler) {
    var id, value;
    id = record['id'];
    if (id == null) {
      throw new Error("unable to register record without ID:\n" + (rpr(record)));
    }

    /* Records whose only attribute is the ID field are replaced by `1`: */
    value = (Object.keys(record)).length === 1 ? 1 : record;
    return registry.put(id, value, (function(_this) {
      return function(error) {
        if (error != null) {
          return handler(error);
        }
        return handler(null, record);
      };
    })(this));
  };

  this.$register = function(registry) {
    return $((function(_this) {
      return function(record, handler) {
        return _this.register(registry, record, function(error) {
          if (error != null) {
            return handler(error);
          }
          return handler(null, record);
        });
      };
    })(this));
  };

  this.register_2 = function(registry, record, handler) {

    /* TAINT kludge, change to using strings as records */
    var entries, facet_route, has_index, has_primary, has_secondary, id, id_1, idn, idn_1, key, meta_value, name, realm, realm_1, route, tasks, type, type_1, value, _ref, _ref1, _ref10, _ref11, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    id = record['id'];
    if (id == null) {
      throw new Error("unable to register record without ID:\n" + (rpr(record)));
    }
    meta_value = '1';
    entries = [];

    /* TAINT kludge, must be changed in GTFS reader */
    _ref = id.split('/'), realm = _ref[0], type = _ref[1], idn = _ref[2];
    route = KEY.new_route(realm, type);
    key = KEY.new_node(realm, type, idn);
    entries.push([key, JSON.stringify(record)]);
    for (name in record) {
      value = record[name];

      /* TAINT make configurable */
      if (name === 'id') {
        continue;
      }
      if (name === 'gtfs-id') {
        continue;
      }
      if (name === 'gtfs-type') {
        continue;
      }
      facet_route = KEY.new_route(realm, type, name);
      if ((has_index = (_ref1 = indexes['direct']) != null ? _ref1['facet'] : void 0) != null) {
        has_primary = (_ref2 = (_ref3 = has_index['primary']) != null ? _ref3[facet_route] : void 0) != null ? _ref2 : false;
        has_secondary = (_ref4 = (_ref5 = has_index['secondary']) != null ? _ref5[facet_route] : void 0) != null ? _ref4 : false;
        if (has_primary || has_secondary) {
          if (has_primary) {
            key = KEY.new_facet(realm, type, idn, name, value);
            entries.push([key, meta_value]);
          }
          if (has_secondary) {
            key = KEY.new_secondary_facet(realm, type, idn, name, value);
            entries.push([key, meta_value]);
          }
        }
      }
      if ((has_index = (_ref6 = indexes['direct']) != null ? _ref6['link'] : void 0) != null) {
        has_primary = (_ref7 = (_ref8 = has_index['primary']) != null ? _ref8[facet_route] : void 0) != null ? _ref7 : false;
        has_secondary = (_ref9 = (_ref10 = has_index['secondary']) != null ? _ref10[facet_route] : void 0) != null ? _ref9 : false;
        if (has_primary || has_secondary) {

          /* TAINT inefficiently first splitting, then joining */
          id_1 = value;
          _ref11 = KEY.split_id(id_1), realm_1 = _ref11[0], type_1 = _ref11[1], idn_1 = _ref11[2];
          if (has_primary) {
            key = KEY.new_link(realm, type, idn, realm_1, type_1, idn_1, 0);
            entries.push([key, meta_value]);
          }
          if (has_secondary) {
            key = KEY.new_secondary_link(realm, type, idn, realm_1, type_1, idn_1, 0);
            entries.push([key, meta_value]);
          }
        }
      }
    }
    tasks = (function() {
      var _i, _len, _ref12, _results;
      _results = [];
      for (_i = 0, _len = entries.length; _i < _len; _i++) {
        _ref12 = entries[_i], key = _ref12[0], value = _ref12[1];
        _results.push({
          type: 'put',
          key: key,
          value: value
        });
      }
      return _results;
    })();
    return registry.batch(tasks, (function(_this) {
      return function(error) {
        return handler(error != null ? error : null);
      };
    })(this));
  };

  this.$register_2 = function(registry) {
    return $((function(_this) {
      return function(record, handler) {
        return _this.register_2(registry, record, function(error) {
          if (error != null) {
            return handler(error);
          }
          return handler(null, record);
        });
      };
    })(this));
  };

  this.register_deferred_properties = function(registry, handler) {

    /* TAINT simplify */

    /* possible to rewrite in terms of a pipe? */
    var count, entry_type, level, level_index, query, source_selector, target_facet_name, type_index, _ref, _results;
    count = 0;
    _ref = indexes['inferred'];
    _results = [];
    for (entry_type in _ref) {
      type_index = _ref[entry_type];
      _results.push((function() {
        var _results1;
        _results1 = [];
        for (level in type_index) {
          level_index = type_index[level];
          _results1.push((function() {
            var _i, _len, _ref1, _results2;
            _results2 = [];
            for (_i = 0, _len = level_index.length; _i < _len; _i++) {
              _ref1 = level_index[_i], source_selector = _ref1[0], target_facet_name = _ref1[1];
              query = {
                gte: source_selector,
                lte: KEY.lte_from_gte(source_selector)
              };
              _results2.push(registry.createKeyStream(query).on('data', (function(_this) {
                return function(source_key) {
                  var proxy_idn, proxy_node_id, proxy_node_key, proxy_realm, proxy_type, source_entry, source_idn, source_node_id, source_realm, source_type, _ref2, _ref3;
                  source_entry = KEY.read(source_key);

                  /* TAINT specific to links */
                  source_node_id = source_entry['id'];
                  proxy_node_id = source_entry['target'];

                  /* TAINT inefficiently splitting and joining key */
                  _ref2 = KEY.split_id(source_node_id), source_realm = _ref2[0], source_type = _ref2[1], source_idn = _ref2[2];

                  /* TAINT inefficiently splitting and joining key */
                  _ref3 = KEY.split_id(proxy_node_id), proxy_realm = _ref3[0], proxy_type = _ref3[1], proxy_idn = _ref3[2];
                  proxy_node_key = KEY.new_node(proxy_realm, proxy_type, proxy_idn);
                  return registry.get(proxy_node_key, function(error, proxy_node) {
                    var distance, key, target_idn, target_realm, target_type, target_value, _ref4;
                    if (error != null) {
                      return handler(error);
                    }

                    /* TAINT why is this not done automatically? */
                    proxy_node = JSON.parse(proxy_node);
                    target_value = proxy_node[target_facet_name];

                    /* TAINT kludge */
                    if (target_value == null) {
                      return handler(new Error("facet " + (rpr(target_facet_name)) + " not defined in " + (rpr(target_node))));
                    }
                    switch (level) {
                      case 'secondary':
                        switch (entry_type) {
                          case 'link':

                            /* TAINT inefficiently splitting and joining key */
                            _ref4 = KEY.split_id(target_value), target_realm = _ref4[0], target_type = _ref4[1], target_idn = _ref4[2];
                            distance = source_entry['distance'] + 1;
                            key = KEY.new_secondary_link(source_realm, source_type, source_idn, target_realm, target_type, target_idn, distance);
                            return registry.put(key, '1', function(error) {
                              if (error != null) {
                                return handler(error);
                              }
                              if (count % 1000 === 0) {
                                whisper(count);
                              }
                              return count += 1;
                            });
                          default:
                            throw 'XXX';
                        }
                        break;
                      default:
                        throw 'XXX';
                    }
                  });
                };
              })(this)).on('error', function(error) {
                return handler(error);
              }).on('end', function() {
                return handler(null);
              }));
            }
            return _results2;
          }).call(this));
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  if (module.parent == null) {
    registry = this.new_registry();
    this.register_deferred_properties(registry, function(error, data) {
      if (error != null) {
        throw error;
      }
      return help(data);
    });
  }

}).call(this);
