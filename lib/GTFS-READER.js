// Generated by CoffeeScript 1.7.1
(function() {
  var $, ASYNC, DEV, P, REGISTRY, TEXT, TRM, TYPES, alert, badge, datasource_infos, debug, echo, global_data_limit, help, info, log, njs_fs, options, rainbow, registry, rpr, urge, warn, whisper, _ref, _ref1,
    __slice = [].slice;

  njs_fs = require('fs');

  TYPES = require('coffeenode-types');

  TEXT = require('coffeenode-text');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'TIMETABLE/GTFS-READER';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);

  options = require('../options');

  global_data_limit = (_ref = (_ref1 = options['data']) != null ? _ref1['limit'] : void 0) != null ? _ref : Infinity;

  datasource_infos = (require('./get-datasource-infos'))();

  REGISTRY = require('./REGISTRY');

  ASYNC = require('async');


  /* https://github.com/loveencounterflow/pipedreams */

  P = require('pipedreams');

  $ = P.$.bind(P);

  DEV = options['mode'] === 'dev';

  this.$register = function(registry) {
    return $((function(_this) {
      return function(record, handler) {
        REGISTRY.register_gtfs(registry, record);
        return handler(null, record);
      };
    })(this));
  };

  this.$convert_latlon = function() {
    return $((function(_this) {
      return function(record, handler) {
        record['lat'] = parseFloat(record['lat']);
        record['lon'] = parseFloat(record['lon']);
        return handler(null, record);
      };
    })(this));
  };

  this.read_agency = function(registry, route, handler) {
    var input;
    input = P.create_readstream(route, 'agency');
    input.pipe(P.$split()).pipe(P.$skip_empty()).pipe(P.$parse_csv()).pipe(this.$clean_agency_record()).pipe(P.$delete_prefix('agency_')).pipe(P.$set('%gtfs-type', 'agency')).pipe(P.$rename('id', '%gtfs-id')).pipe(this.$clean_agency_record()).pipe(P.$dasherize_field_names()).pipe(this.$register(registry)).pipe(P.$collect_sample(input, 1, function(_, sample) {
      return whisper('agency', sample);
    })).on('end', (function(_this) {
      return function() {
        return handler(null);
      };
    })(this));
    return null;
  };

  this.$clean_agency_record = function() {
    return $((function(_this) {
      return function(record, handler) {
        delete record['agency_phone'];
        delete record['agency_lang'];
        return handler(null, record);
      };
    })(this));
  };


  /* TAINT name clash (filesystem route vs. GTFS route) */

  this.read_routes = function(registry, route, handler) {
    var input;
    input = P.create_readstream(route, 'routes');
    input.pipe(P.$split()).pipe(P.$skip_empty()).pipe(P.$parse_csv()).pipe(this.$filter_routes(registry)).pipe(this.$clean_routes_record()).pipe(P.$dasherize_field_names()).pipe(P.$set('%gtfs-type', 'routes')).pipe(P.$rename('route-id', '%gtfs-id')).pipe(P.$rename('agency-id', '%gtfs-agency-id')).pipe(P.$rename('route-short-name', 'name')).pipe(this.$register(registry)).pipe(P.$collect_sample(input, 1, function(_, sample) {
      return whisper('route', sample);
    })).on('end', (function(_this) {
      return function() {
        return handler(null);
      };
    })(this));
    return null;
  };

  this.$filter_routes = function(registry) {
    return $((function(_this) {
      return function(record, handler) {

        /* TAINT non-general filter */
        var matcher;
        matcher = DEV ? /^U4/ : /U/;
        if (!matcher.test(record['route_short_name'])) {
          return handler(null);
        }
        return handler(null, record);
      };
    })(this));
  };

  this.$clean_routes_record = function() {
    return $((function(_this) {
      return function(record, handler) {
        delete record['route_long_name'];
        delete record['route_desc'];
        delete record['route_url'];
        delete record['route_color'];
        delete record['route_text_color'];
        return handler(null, record);
      };
    })(this));
  };

  this.read_calendar_dates = function(registry, route, handler) {
    var input;
    input = P.create_readstream(route, 'calendar_dates');
    input.pipe(P.$split()).pipe(P.$skip_empty()).pipe(P.$parse_csv()).pipe(this.$filter_calendar_dates(registry)).pipe(this.$clean_calendar_date_record()).pipe(P.$set('%gtfs-type', 'calendar_dates')).pipe(P.$rename('service_id', '%gtfs-id')).pipe(this.$register(registry)).pipe(P.$collect_sample(input, 1, function(_, sample) {
      return whisper('service', sample);
    })).on('end', (function(_this) {
      return function() {
        return handler(null);
      };
    })(this));
    return null;
  };

  this.$filter_calendar_dates = function(registry) {
    return $((function(_this) {
      return function(record, handler) {

        /* TAINT non-general filter */
        if (record['date'] !== '20140624') {
          return handler(null);
        }
        return handler(null, record);
      };
    })(this));
  };

  this.$clean_calendar_date_record = function() {
    return $((function(_this) {
      return function(record, handler) {
        delete record['exception_type'];
        return handler(null, record);
      };
    })(this));
  };

  this.read_trips = function(registry, route, handler) {
    var input, ratio;
    input = P.create_readstream(route, 'trips');
    ratio = DEV ? 1 / 100 : 1;
    input.pipe(P.$split()).pipe(P.$skip_empty()).pipe(P.$parse_csv()).pipe(this.$filter_trips(registry)).pipe(P.$sample(ratio, {
      headers: true,
      seed: 5
    })).pipe(this.$clean_trip_record()).pipe(P.$delete_prefix('trip_')).pipe(P.$dasherize_field_names()).pipe(P.$set('%gtfs-type', 'trips')).pipe(P.$set('%gtfs-stoptimes', null)).pipe(P.$rename('id', '%gtfs-id')).pipe(P.$rename('route-id', '%gtfs-routes-id')).pipe(P.$rename('service-id', '%gtfs-service-id')).pipe(this.$register(registry)).pipe(P.$collect_sample(input, 1, function(_, sample) {
      return whisper('trip', sample);
    })).on('end', (function(_this) {
      return function() {
        return handler(null);
      };
    })(this));
    return null;
  };

  this.$filter_trips = function(registry) {
    return $((function(_this) {
      return function(record, handler) {
        if (registry['%gtfs']['routes'][record['route_id']] == null) {
          return handler(null);
        }
        if (registry['%gtfs']['calendar_dates'][record['service_id']] == null) {
          return handler(null);
        }
        return handler(null, record);
      };
    })(this));
  };

  this.$clean_trip_record = function() {
    return $((function(_this) {
      return function(record, handler) {
        delete record['trip_short_name'];
        delete record['direction_id'];
        delete record['block_id'];
        delete record['shape_id'];
        return handler(null, record);
      };
    })(this));
  };

  this.read_stop_times = function(registry, route, handler) {
    var input, ratio;
    input = P.create_readstream(route, 'stop_times');
    ratio = DEV ? 1 / 1e4 : 1;
    input.pipe(P.$split()).pipe(P.$skip_empty()).pipe(P.$parse_csv()).pipe(this.$filter_stop_times(registry)).pipe(this.$clean_stop_times_record()).pipe(P.$set('%gtfs-type', 'stop_times')).pipe(P.$dasherize_field_names()).pipe(P.$rename('trip-id', '%gtfs-trip-id')).pipe(P.$rename('stop-id', '%gtfs-stop-id')).pipe(P.$rename('arrival-time', 'arr')).pipe(P.$rename('departure-time', 'dep')).pipe(this.$add_stoptimes_gtfsid()).pipe(this.$add_stoptime_to_trip(registry)).pipe(this.$register(registry)).pipe(this.$register_stop_id(registry)).pipe(P.$collect_sample(input, 1, function(_, sample) {
      return whisper('stop_time', sample);
    })).on('end', (function(_this) {
      return function() {
        return handler(null);
      };
    })(this));
    return null;
  };

  this.$clean_stop_times_record = function() {
    return $((function(_this) {
      return function(record, handler) {
        delete record['stop_headsign'];
        delete record['pickup_type'];
        delete record['drop_off_type'];
        delete record['shape_dist_traveled'];
        return handler(null, record);
      };
    })(this));
  };

  this.$filter_stop_times = function(registry) {
    return $((function(_this) {
      return function(record, handler) {
        if (registry['%gtfs']['trips'][record['trip_id']] == null) {
          return handler(null);
        }
        return handler(null, record);
      };
    })(this));
  };

  this.$add_stoptimes_gtfsid = function() {
    var idx;
    idx = 0;
    return $((function(_this) {
      return function(record, handler) {
        record['%gtfs-id'] = "" + idx;
        idx += 1;
        return handler(null, record);
      };
    })(this));
  };

  this.$add_stoptime_to_trip = function(registry) {
    return $((function(_this) {
      return function(record, handler) {
        var gtfs_trip_id, idx, target, trip_record;
        gtfs_trip_id = record['%gtfs-trip-id'];
        trip_record = registry['%gtfs']['trips'][gtfs_trip_id];
        if (trip_record == null) {
          debug(registry['%gtfs']['trips']);
          return handler(new Error("unable to locate trip " + (rpr(gtfs_trip_id)) + " for stoptime: " + (rpr(record))));
        }
        target = trip_record['%gtfs-stoptimes'] != null ? trip_record['%gtfs-stoptimes'] : trip_record['%gtfs-stoptimes'] = [];
        idx = (parseInt(record['stop-sequence'], 10)) - 1;
        if (target[idx] != null) {
          return handler(new Error("duplicate stoptime " + (rpr(record)) + " in trip " + (rpr(trip_record))));
        }
        target[idx] = record;
        return handler(null, record);
      };
    })(this));
  };

  this.$register_stop_id = function(registry) {
    var target, _base;
    target = (_base = registry['%state'])['gtfs-stop-ids'] != null ? _base['gtfs-stop-ids'] : _base['gtfs-stop-ids'] = {};
    return $((function(_this) {
      return function(record, handler) {
        target[record['%gtfs-stop-id']] = 1;
        return handler(null, record);
      };
    })(this));
  };

  this.read_stops = function(registry, route, handler) {
    var input;
    input = P.create_readstream(route, 'stops');
    input.pipe(P.$split()).pipe(P.$skip_empty()).pipe(P.$parse_csv()).pipe(this.$filter_stops(registry)).pipe(this.$clean_stops_record()).pipe(P.$delete_prefix('stop_')).pipe(P.$set('%gtfs-type', 'stops')).pipe(P.$rename('id', '%gtfs-id')).pipe(this.$convert_latlon()).pipe(this.$register(registry)).pipe(P.$collect_sample(input, 1, function(_, sample) {
      return whisper('stop', sample);
    })).on('end', (function(_this) {
      return function() {
        _this._clear_stops_id_cache(registry);
        return handler(null);
      };
    })(this));
    return null;
  };

  this._clear_stops_id_cache = function(registry) {
    delete registry['%state']['gtfs-stop-ids'];
    return null;
  };

  this.$filter_stops = function(registry) {
    var target;
    target = registry['%state']['gtfs-stop-ids'];
    if (target == null) {
      throw new Error("stops should be read after stop_times");
    }
    return $((function(_this) {
      return function(record, handler) {
        if (!target[record['stop_id']]) {
          return handler(null);
        }
        return handler(null, record);
      };
    })(this));
  };

  this.$clean_stops_record = function() {
    return $((function(_this) {
      return function(record, handler) {
        delete record['stop_desc'];
        delete record['zone_id'];
        delete record['stop_url'];
        delete record['location_type'];
        delete record['parent_station'];
        return handler(null, record);
      };
    })(this));
  };

  this.main = function(registry, handler) {
    var gtfs_type, message, messages, method, method_name, no_method, no_source, ok_types, route, route_by_types, source_name, t0, tasks, _fn, _i, _j, _k, _len, _len1, _len2, _ref2, _ref3;
    t0 = 1 * new Date();
    for (source_name in datasource_infos) {
      route_by_types = datasource_infos[source_name];
      tasks = [];
      no_source = [];
      no_method = [];
      ok_types = [];
      _ref2 = options['data']['gtfs-types'];
      _fn = (function(_this) {
        return function(method_name, method, route) {
          return tasks.push(function(async_handler) {
            help("" + badge + "/" + method_name);
            return method(registry, route, function() {
              var P;
              P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
              info("" + badge + "/" + method_name);
              return async_handler.apply(null, P);
            });
          });
        };
      })(this);
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        gtfs_type = _ref2[_i];
        route = route_by_types[gtfs_type];
        if (route == null) {
          no_source.push("skipping " + source_name + "/" + gtfs_type + " (no source file)");
          continue;
        }
        help("found data source for " + source_name + "/" + gtfs_type);
        method_name = "read_" + gtfs_type;
        method = this[method_name];
        if (method == null) {
          no_method.push("no method to read GTFS data of type " + (rpr(gtfs_type)) + "; skipping");
          continue;
        }
        method = method.bind(this);
        ok_types.push(gtfs_type);
        _fn(method_name, method, route);
      }
      _ref3 = [no_source, no_method];
      for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
        messages = _ref3[_j];
        for (_k = 0, _len2 = messages.length; _k < _len2; _k++) {
          message = messages[_k];
          warn(message);
        }
      }
      info("reading data for " + ok_types.length + " type(s)");
      info("  (" + (ok_types.join(', ')) + ")");
    }
    ASYNC.series(tasks, (function(_this) {
      return function(error) {
        var t1;
        if (error != null) {
          throw error;
        }
        t1 = 1 * new Date();
        urge('dt:', (t1 - t0) / 1000);
        return handler(null, registry);
      };
    })(this));
    return null;
  };

  if (module.parent == null) {
    registry = REGISTRY.new_registry();
    this.main(registry, function(error, registry) {
      if (error != null) {
        throw error;
      }
      return info(registry);
    });
  }

}).call(this);
