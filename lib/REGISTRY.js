// Generated by CoffeeScript 1.7.1
(function() {
  var $, ASYNC, KEY, P, TRM, TYPES, alert, badge, debug, echo, help, indexes, info, log, new_db, njs_fs, options, rainbow, registry, rpr, test_folder_exists, urge, warn, whisper;

  njs_fs = require('fs');

  TYPES = require('coffeenode-types');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'TIMETABLE/REGISTRY';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);

  options = require('../options');

  indexes = options['data']['indexes'];

  new_db = require('level');

  ASYNC = require('async');

  P = require('pipedreams');

  $ = P.$.bind(P);

  KEY = require('./KEY');

  test_folder_exists = function(route) {
    var is_folder;
    if (!njs_fs.existsSync(route)) {
      return false;
    }
    is_folder = (njs_fs.statSync(route)).isDirectory();
    if (!is_folder) {
      throw new Error("route exists but is not a folder: " + route);
    }
    return true;
  };

  this.new_registry = function(route) {
    if (route == null) {
      route = options['levelup']['route'];
    }
    return new_db(route, options['levelup']['new']);
  };

  this._new_registry = function(route) {
    var folder_exists, registry;
    if (route == null) {
      route = options['levelup']['route'];
    }
    folder_exists = test_folder_exists(route);
    registry = this.new_registry(route);
    return [folder_exists, registry];
  };

  this.close = function(registry, handler) {
    return registry.close((function(_this) {
      return function(error) {
        help('registry closed');
        return handler(error);
      };
    })(this));
  };

  this.flush = function(registry, handler) {
    return registry.close((function(_this) {
      return function(error) {
        if (error != null) {
          return handler(error);
        }
        return registry.open(function(error) {
          help('registry flushed');
          return handler(error, registry);
        });
      };
    })(this));
  };

  this.register = function(registry, record, handler) {
    var id, value;
    id = record['id'];
    if (id == null) {
      throw new Error("unable to register record without ID:\n" + (rpr(record)));
    }

    /* Records whose only attribute is the ID field are replaced by `1`: */
    value = (Object.keys(record)).length === 1 ? 1 : record;
    return registry.put(id, value, (function(_this) {
      return function(error) {
        if (error != null) {
          return handler(error);
        }
        return handler(null, record);
      };
    })(this));
  };

  this.$register = function(registry) {
    return $((function(_this) {
      return function(record, handler) {
        return _this.register(registry, record, function(error) {
          if (error != null) {
            return handler(error);
          }
          return handler(null, record);
        });
      };
    })(this));
  };

  this.register_2 = function(registry, record, handler) {

    /* TAINT kludge, change to using strings as records */
    var entries, facet_route, has_index, has_primary, has_secondary, id, idn, idn_1, key, meta_value, name, realm, realm_1, route, tasks, type, type_1, value, _, _ref, _ref1, _ref10, _ref11, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    id = record['id'];
    if (id == null) {
      throw new Error("unable to register record without ID:\n" + (rpr(record)));
    }
    meta_value = '1';
    entries = [];

    /* TAINT kludge, must be changed in GTFS reader */
    _ref = id.split('/'), realm = _ref[0], type = _ref[1], idn = _ref[2];
    route = KEY.new_route(realm, type);
    key = KEY.new_node(realm, type, idn);
    entries.push([key, JSON.stringify(record)]);
    for (name in record) {
      value = record[name];

      /* TAINT make configurable */
      if (name === 'id') {
        continue;
      }
      if (name === 'gtfs-id') {
        continue;
      }
      if (name === 'gtfs-type') {
        continue;
      }
      facet_route = KEY.new_route(realm, type, name);
      if ((has_index = (_ref1 = indexes['direct']) != null ? _ref1['facet'] : void 0) != null) {
        has_primary = (_ref2 = (_ref3 = has_index['primary']) != null ? _ref3[facet_route] : void 0) != null ? _ref2 : false;
        has_secondary = (_ref4 = (_ref5 = has_index['secondary']) != null ? _ref5[facet_route] : void 0) != null ? _ref4 : false;
        if (has_primary || has_secondary) {
          if (has_primary) {
            key = KEY.new_facet(realm, type, idn, name, value);
            entries.push([key, meta_value]);
          }
          if (has_secondary) {
            key = KEY.new_secondary_facet(realm, type, idn, name, value);
            entries.push([key, meta_value]);
          }
        }
      }
      if ((has_index = (_ref6 = indexes['direct']) != null ? _ref6['link'] : void 0) != null) {
        has_primary = (_ref7 = (_ref8 = has_index['primary']) != null ? _ref8[facet_route] : void 0) != null ? _ref7 : false;
        has_secondary = (_ref9 = (_ref10 = has_index['secondary']) != null ? _ref10[facet_route] : void 0) != null ? _ref9 : false;
        if (has_primary || has_secondary) {
          idn_1 = value;
          _ref11 = name.split('-'), realm_1 = _ref11[0], type_1 = _ref11[1], _ = _ref11[2];
          if (has_primary) {
            key = KEY.new_link(realm, type, idn, realm_1, type_1, idn_1, 0);
            entries.push([key, meta_value]);
          }
          if (has_secondary) {
            key = KEY.new_secondary_link(realm, type, idn, realm_1, type_1, idn_1, 0);
            entries.push([key, meta_value]);
          }
        }
      }
    }
    tasks = (function() {
      var _i, _len, _ref12, _results;
      _results = [];
      for (_i = 0, _len = entries.length; _i < _len; _i++) {
        _ref12 = entries[_i], key = _ref12[0], value = _ref12[1];
        _results.push({
          type: 'put',
          key: key,
          value: value
        });
      }
      return _results;
    })();
    return registry.batch(tasks, (function(_this) {
      return function(error) {
        return handler(error != null ? error : null);
      };
    })(this));
  };

  this.$register_2 = function(registry) {
    return $((function(_this) {
      return function(record, handler) {
        return _this.register_2(registry, record, function(error) {
          if (error != null) {
            return handler(error);
          }
          return handler(null, record);
        });
      };
    })(this));
  };

  this.register_deferred_properties = function(registry, handler) {
    var entry_type, level, level_index, query, source_selector, target_facet_name, type, type_index, _ref, _results;
    _ref = indexes['inferred'];
    _results = [];
    for (type in _ref) {
      type_index = _ref[type];
      _results.push((function() {
        var _results1;
        _results1 = [];
        for (level in type_index) {
          level_index = type_index[level];
          _results1.push((function() {
            var _i, _len, _ref1, _results2;
            _results2 = [];
            for (_i = 0, _len = level_index.length; _i < _len; _i++) {
              _ref1 = level_index[_i], entry_type = _ref1[0], source_selector = _ref1[1], target_facet_name = _ref1[2];
              debug(type, level, source_selector, target_facet_name);
              query = {
                gte: source_selector,
                lte: KEY.lte_from_gte(source_selector)
              };
              _results2.push(registry.createKeyStream(query).on('data', function(source_key) {
                var target_idn, target_node_key, target_realm, target_type, _ref2;
                _ref2 = KEY.split_id((KEY.read(source_key))['target']), target_realm = _ref2[0], target_type = _ref2[1], target_idn = _ref2[2];
                target_node_key = KEY.new_node(target_realm, target_type, target_idn);
                return registry.get(target_node_key, function(error, target_node) {
                  var target_facet_value;
                  if (error != null) {
                    return handler(error);
                  }

                  /* TAINT why is this not done automatically? */
                  target_node = JSON.parse(target_node);
                  target_facet_value = target_node[target_facet_name];

                  /* TAINT kludge */
                  info((target_facet_name.replace(/-/g, '/')) + '/' + target_facet_value);
                  if (target_facet_value == null) {
                    return handler(new Error("facet " + (rpr(target_facet_name)) + " not defined in " + (rpr(target_node))));
                  }
                });
              }).on('error', function(error) {
                return handler(error);
              }).on('end', function() {
                return handler(null);
              }));
            }
            return _results2;
          })());
        }
        return _results1;
      })());
    }
    return _results;
  };

  if (module.parent == null) {
    registry = this.new_registry();
    this.register_deferred_properties(registry, function(error, data) {
      if (error != null) {
        throw error;
      }
      return help(data);
    });
  }

}).call(this);
